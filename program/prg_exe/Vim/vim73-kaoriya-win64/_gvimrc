" **************************************************************************************************
" *****									キーバインド設定									   *****
" **************************************************************************************************
" <<キーバインド説明>>
"	- map：キー入力を別のキーに割り当てる。
"	- noremap：キー入力を別のキーに割り当てる。
"			   ただし、再マップされないので、マップが入れ子になったり再帰的になることがない。
"		map と noremap の違いについては、以下 URL 参照
"		  http://cocopon.me/blog/?p=3871
"	- <sirent>：メッセージは表示されず、 メッセージ履歴に残らない
"	- <expr>：引数が式 (スクリプト) として扱われる。マップが実行されたときに、式が評価される。
"=== モード共通 ===
	noremap		<silent>			n			nzz											" 検索結果を画面中央に
	noremap		<silent>			N			Nzz											" 検索結果を画面中央に
	noremap		<silent>			*			*Nzz										" 検索結果を画面中央に
	noremap		<silent>			#			#nzz										" 検索結果を画面中央に
	noremap		<silent>			K			g*zz										" 検索結果を画面中央に
	noremap		<silent>			g#			g#zz										" 検索結果を画面中央に
	noremap		<silent>			x			"_x											" １文字削除（切り取りなし）
	noremap		<silent>			<s-h>		^											" カーソルを先頭に移動
	noremap		<silent>			<s-l>		$											" カーソルを末尾に移動
	noremap		<silent>			<tab>		a<tab><esc>									" タブ挿入
	noremap		<silent>			<space>		<nop>										" スペースキー無効
	noremap		<silent>			<c-j>		5jzz										" カーソル移動＋画面移動（下）
	noremap		<silent>			<c-k>		5kzz										" カーソル移動＋画面移動（上）
	noremap		<silent>			<c-h>		10zh10h										" カーソル移動＋画面移動（左）
	noremap		<silent>			<c-l>		10zl10l										" カーソル移動＋画面移動（右）
	map			<silent>			<c-m>		oa<esc>x									" インデントを維持して改行
	noremap		<silent>			<c-q>		<c-w>w										" ウィンドウ切替（次へ）
	noremap		<silent>			<c-s-q>		<c-w>W										" ウィンドウ切替（前へ）
	noremap		<silent>			<c-tab>		gt											" タブ切替（次へ）
	noremap		<silent>			<c-s-tab>	gT											" タブ切替（前へ）
	noremap		<silent>			<c-w>		<nop>
	noremap		<silent>			<c-w>		:tabclose<cr>								" タブを閉じる
	noremap		<silent>			<c-s-n>		:tabnew<cr>									" 新規タブを開く
	noremap		<silent>			<c-s-g>		:call ExecuteHNXgrep()<cr>					" HNXGrep を実行
"	noremap							/			/\v											" 検索モード変更
	noremap		<silent>			<esc><esc>	:nohlsearch<cr>								" ハイライト解除
	noremap							ciy			ciw<c-r>0<esc>b								" 単語コピー
	
	noremap		<silent>			<F1>		:call BufferList()<cr>						" バッファリスト作成
	noremap		<silent>			<F2>		:Tlist<cr>									" タグリスト作成
	noremap		<silent>			<F3>		a<C-R>=strftime("%Y/%m/%d (%a)")<cr><esc>	" 現在日時出力
	noremap		<silent>			<F4>		a<C-R>=strftime("%H:%M:%S")<cr><esc>		" 現在時刻出力
	noremap		<silent>			<F5>		:call ExecCurrentScript()<cr>				" 現在のプログラムを実行
	noremap		<silent>			<F6>		:vs<cr><c-w>wggVGy:q<cr><c-w>W				" 全体をコピー
"	noremap		<silent>			<F7>		:Vexplore<cr>								" Explorerを起動
	noremap		<silent>			<F8>		:call ToggleFontSize()<cr>					" フォントサイズをトグル
"	noremap		<silent>			<F9>		<nop>
	noremap		<silent>			<F10>		:call UpdateTagFile()<cr>					" タグファイル更新
	noremap		<silent>			<F11>		:set expandtab<cr>:retab!<cr>				" タブ⇒空白 変換
	noremap		<silent>			<F12>		:set noexpandtab<cr>:retab!<cr>				" 空白⇒タブ 変換
	
	noremap		<silent>			<c-F1>		:call CopyFilePath()<cr>					" 現在ファイルパスコピー
	noremap		<silent>			<c-F2>		:call CopyFileName()<cr>					" 現在ファイル名コピー
	noremap		<silent>			<c-F3>		:call CopyDirPath()<cr>						" 現在フォルダパスコピー
	noremap		<silent>			<c-F5>		:so %<cr>									" 現在設定ファイル読み込み
	
	noremap		<silent>	<expr>	gp			'`[' . strpart(getregtype(), 0, 1) . '`]'	" ペーストしたテキストを再選択できるようにする
	
"=== ノーマルモード ===
	nmap		<silent>			mi			kyiwjciy<c-a>j								" 前行の単語をコピーしてインクリメント
	
"=== 挿入モード ===
	inoremap	<silent>			<c-j>		<esc>										" Ctrl+J でノーマルモードに移行
	
"=== ヴィジュアルモード ===
	vnoremap	<silent>			<			<gv											" インデント左シフト
	vnoremap	<silent>			>			>gv											" インデント右シフト
	vnoremap	<silent>			<F3>		:s/\s*$//<cr>:nohlsearch<cr>				" 末尾の空白を削除
	vnoremap	<silent>			<F4>		:s/\\/\//g<cr>								" ファイルパス区切り変換（\→/）
	vnoremap	<silent>			<F5>		:s/\v_(.)/\u\1/g<cr>						" スネークケース⇒キャメルケース変換
	vnoremap	<silent>			<F6>		:s/\v([A-Z])/_\L\1/g<cr>					" キャメルケース⇒スネークケース変換

" ==============================================================================
" Gtags用キーバインド
" [参照] http://cha.la.coocan.jp/doc/gnu_global.html#sec10
" ==============================================================================
	map								<C-o>		:GtagsCursor<CR>
	nnoremap						<C-d>		:Gtags <C-r><C-w><CR>
	nnoremap						<C-e>		:Gtags -r <C-r><C-w><CR>
	nnoremap						gs			:Gtags -s <C-r><C-w><CR>
	nnoremap						gG			:Gtags -g <C-r><C-w><CR>
	nnoremap						,d			:<C-u>Gtags -f %<CR>
	nnoremap						<C-t>		<C-o>

" **************************************************************************************************
" *****										  基本設定										   *****
" **************************************************************************************************
" ==============================================================================
" ファイルパス設定
" ==============================================================================
	let g:sCtagsPath = "C:/prg_exe/ctags58j2bin"
	let g:sGtagsPath = "C:/prg_exe/glo627wb/bin"
	let g:sMarkVimPath = substitute( $VIM, "\\", "/", "g" ) . "/bundle/mark.vim/plugin/mark.vim"
	let g:sGrepTrgtDirPath = "C:/codes_sample/c/FreeRTOSV7.1.1/Source"
	let g:sHNXGrepPath = substitute( $VIM, "\\", "/", "g" ) . "/../../HNXgrep/HNXgrep.exe"
	
" ==============================================================================
" 基本設定
" ==============================================================================
"	set guifont=MS_Gothic:h10:cSHIFTJIS					" フォントサイズ設定（フォントサイズ設定は以下の「フォントサイズ設定」参照）
"	set columns=82										" ウィンドウの横幅を～カラムにします
"	set lines=35										" ウィンドウの高さを～行にします
	set guioptions-=m									" メニューバーを非表示
	set guioptions-=T									" ツールバーを非表示
"	set guioptions+=a									" ビジュアルモードで選択している箇所をクリップボードにコピー
	set guioptions+=rl									" 縦スクロールバー表示
"	set guioptions+=b									" 横スクロールバー表示
	set guioptions-=e									" gVimでもテキストベースのタブページを使う
	set number											" 行番号表示
	set foldcolumn=3									" 折り畳み行のネスト表示
"	set relativenumber									" 相対行番号表示(7.3)
	set ruler											" ルーラーを表示 (noruler:非表示)
	set cmdheight=2										" コマンドラインの高さ (gvimはgvimrcで指定)
	set laststatus=2									" コマンドをステータス行に表示
	set statusline=										" ステータスライン表示設定
	set statusline+=\ [BufNo:\%03.3n]					" ステータスライン表示設定 buffer number
"	set statusline+=\ [Func:%{cfi#get_func_name()}]		" ステータスライン表示設定 func name（タグジャンプに異常をきたすため、使用しない）
"	set statusline+=\ %F								" ステータスライン表示設定 filepath
	set statusline+=\ <<%t>>							" ステータスライン表示設定 filename
"	set statusline+=\ %-40(\ %m%r%h%w\ %)				" ステータスライン表示設定 status flags
	set statusline+=\ %=								" ステータスライン表示設定 right align remainder
	set statusline+=\ [Frmt:%{&fenc!=''?&fenc:&enc}]	" ステータスライン表示設定 file format
	set statusline+=\ [CR/LF:%{&ff}]					" ステータスライン表示設定 line feed
"	set statusline+=\ [Asc:0x\%02.2B]					" ステータスライン表示設定 ascii code (hex)
	set statusline+=\ [SelRng:%{GetSelRngClmDiff()}x%{GetSelRngRowDiff()}]	" ステータスライン表示設定 select width x height
	set statusline+=\ [XPos:%03v]						" ステータスライン表示設定 cursor position
	set showtabline=2									" タブページを常に表示
	set tabline=%!MakeTabLine()							" タブページのラベルを設定
"	set cursorcolumn									" カーソル列を目立たせる
"	set cursorline										" カーソル行を目立たせる
	set title											" タイトルを表示
	set noshowcmd										" 選択中の行数、列数を表示しない（自作したので不要）
	set fileformat=dos									" 改行をWindowsの形式に変更。
	set nowritebackup									" ファイルの上書きの前にバックアップを作る/作らない
														" set writebackupを指定してもオプション 'backup' がオンでない限り、
														" バックアップは上書きに成功した後に削除される。
	set scrolloff=5										" カーソル周辺行数
	set swapfile										" スワップファイル(.swpファイル)を作成する
	set directory=$VIM									" スワップファイル(.swpファイル)の出力先
	set nobackup										" バックアップファイル(~ファイル)を作成しない
	set hidden											" 編集結果非保存のバッファから、新しいバッファを開くときに警告を出さない
	set history=50										" ヒストリの保存数
	set textwidth=0										" 一行が長くなった場合の自動改行を抑止する
"	set formatoptions+=mM								" 日本語の行の連結時には空白を入力しない
	set formatoptions-=tc								" 一行が長くなった場合の自動改行を抑止する
"	set formatoptions+=q								" 一行が長くなった場合の自動改行を抑止する
	set virtualedit=block								" Visual blockモードでフリーカーソルを有効にする
	set backspace=indent,eol,start						" バックスペースでインデントや改行を削除できるようにする
	set ambiwidth=double								" □や○の文字があってもカーソル位置がずれないようにする
	set wildmenu										" コマンドライン補完するときに強化されたものを使う
	set timeout timeoutlen=3000 ttimeoutlen=100			" キーコードやマッピングされたキー列が完了するのを待つ時間(ミリ秒)
	set clipboard+=unnamed								" クリップボードを共有
	set nrformats-=octal								" <C-a>,<C-x> 実行にて 8 進数を無効にする。
"	set nrformats+=alpha								" <C-a>,<C-x> 実行にて アルファベットを有効にする。
"	set browsedir=buffer								" ファイル保存ダイアログの初期ディレクトリをバッファファイル位置に設定
	set nocompatible									" vi互換をオフ
	set shellslash										" Windowsでディレクトリパスの区切り文字表示に / を使えるようにする
	set showmatch										" 括弧の対応を数秒（0.1秒単位）表示
	set smarttab										" 行頭の余白内で tab を打ち込むと、'shiftwidth' の数だけインデントする。
	set autoindent										" 自動的にインデントする
	set smartindent										" 新しい行を作ったときに高度な自動インデントを行う
	set cinoptions+=:0									" Cインデントの設定
	set whichwrap=b,s,h,l,<,>,[,]						" カーソルを行頭、行末で止まらないようにする
	set tags+=tags;										" タグファイルのパス指定
	set nowrap											" 次のスクロールが可能。 zhで左へスクロール、zlで右へスクロール。 zHで左へ半分スクロール、zLで右へ半分スクロール
	set isfname+=32										" スペースがファイル名に入っていても、gfコマンドで開ける
	set list											" どの文字でタブや改行を表示するかを設定
	set listchars=tab:^\ ,eol:$							"	参考：set listchars=tab:>-,extends:<,trail:-,eol:<
	set nowrapscan										" 検索時にファイルの最後まで行ったら最初に戻らない
	set smartcase										" 大文字小文字の両方が含まれている場合は大文字小文字を区別
	set incsearch										" インクリメンタルサーチ
	set hlsearch										" 検索文字の強調表示
	set ignorecase										" 検索の時に大文字小文字を区別しない
	set iskeyword=a-z,A-Z,48-57,_						" w,bの移動で認識する文字
	set grepprg=internal								" vimgrep をデフォルトのgrepとする場合internal
"	set shortmess+=I									" スプラッシュ(起動時のメッセージ)を表示しない
	set noerrorbells									" エラー時の音とビジュアルベルの抑制(gvimは.gvimrcで設定)
	set visualbell t_vb=								" Beep 音を鳴らなくする
"	set lazyredraw										" マクロ実行中などの画面再描画を行わない
	set display=lastline								" Tab、行末の半角スペースを明示的に表示する
	set softtabstop=4									" ソフトタブストップ（<Tab> の挿入や <BS> の使用等の編集操作をするときに、<Tab> が対応する空白の数）
	set shiftwidth=4									" シフト移動幅（自動インデントやコマンド "<<", ">>" でずれる幅）
	set tabstop=4										" タブストップ（画面上でタブ文字が占める幅）
if has('mouse')
	set mouse=a											" マウスを有効にする
endif
	set viminfo+=n$VIM/_viminfo							" VIMINFO ファイル出力先設定

" ==============================================================================
" カラースキーマ設定
" ==============================================================================
	colorscheme jellybeans_custom
"	colorscheme desert
	highlight NonText		guibg=NONE	guifg=#404040
	highlight SpecialKey	guibg=NONE	guifg=#707070

" ==============================================================================
" window位置の保存と復帰
" ==============================================================================
	if has('unix')
		let s:infofile = '$VIM/.vim/.vimpos'
	else
		let s:infofile = '$VIM/_vimpos'
	endif
	
	function! s:savewindowparam(filename)
		redir => pos
		exec 'winpos'
	
		redir end
		let pos = matchstr(pos, 'x[-0-9 ]\+,\s*y[-0-9 ]\+$')
		let file = expand(a:filename)
		let str = []
		let cmd = 'winpos '.substitute(pos, '[^-0-9 ]', '', 'g')
		cal add(str, cmd)
		let l = &lines
		let c = &columns
		cal add(str, 'set lines='. l.' columns='. c)
		silent! let ostr = readfile(file)
		if str != ostr
			call writefile(str, file)
		endif
	endfunction
	
	augroup savewindowparam
		autocmd!
		execute 'autocmd savewindowparam vimleave * call s:savewindowparam("'.s:infofile.'")'
	augroup end
	
	if filereadable(expand(s:infofile))
		execute 'source '.s:infofile
	endif
	unlet s:infofile

" ==============================================================================
" 挿入モード時、ステータスラインの色を変更
" ==============================================================================
	let g:hi_insert = 'highlight StatusLine guifg=darkblue guibg=darkyellow gui=none ctermfg=blue ctermbg=yellow cterm=none'
	
	if has('syntax')
		augroup InsertHook
			autocmd!
			autocmd InsertEnter * call s:StatusLine('Enter')
			autocmd InsertLeave * call s:StatusLine('Leave')
		augroup END
	endif
	
	let s:slhlcmd = ''
	function! s:StatusLine(mode)
		if a:mode == 'Enter'
			silent! let s:slhlcmd = 'highlight ' . s:GetHighlight('StatusLine')
			silent exec g:hi_insert
		else
			highlight clear StatusLine
			silent exec s:slhlcmd
		endif
	endfunction
	
	function! s:GetHighlight(hi)
		redir => hl
		exec 'highlight '.a:hi
		redir END
		let hl = substitute(hl, '[\r\n]', '', 'g')
		let hl = substitute(hl, 'xxx', '', '')
		return hl
	endfunction

" ==============================================================================
" 全角スペースを表示
"	コメント以外で全角スペースを指定しているので、scriptencodingと、
"	このファイルのエンコードが一致するよう注意！
"	強調表示されない場合、ここでscriptencodingを指定するとうまくいく事があります。
" ==============================================================================
	scriptencoding utf-8
	function! ZenkakuSpace()
		silent! let hi = s:GetHighlight('ZenkakuSpace')
		if hi =~ 'E411' || hi =~ 'cleared$'
			highlight ZenkakuSpace cterm=underline ctermfg=darkgrey gui=underline guifg=darkgrey
		endif
	endfunction
	if has('syntax')
		augroup ZenkakuSpace
			autocmd!
			autocmd ColorScheme		  * call ZenkakuSpace()
			autocmd VimEnter,WinEnter * match ZenkakuSpace /　/
		augroup END
		call ZenkakuSpace()
	endif

" ==============================================================================
" grep,tagsのためカレントディレクトリを
" ファイルと同じディレクトリに移動する
" ==============================================================================
	if exists('+autochdir')
		"autochdirがある場合カレントディレクトリを移動
		set autochdir
	else
		"autochdirが存在しないが、カレントディレクトリを移動したい場合
		au BufEnter * execute ":silent! lcd " . escape(expand("%:p:h"), ' ')
	endif

" ==============================================================================
" 外部で変更のあったファイルを自動的に読み直す(ウィンドウを移動するたび)
" [参照] http://vim-users.jp/2011/03/hack206/
" ==============================================================================
	augroup vimrc-checktime
		autocmd!
		autocmd winenter * checktime
	augroup end

" ==============================================================================
" IME カラー設定
" [参照] http://sites.google.com/site/fudist/Home/vim-nihongo-ban/vim-color
" ==============================================================================
	if has('multi_byte_ime')
		highlight Cursor	guifg=NONE guibg=Yellow
		highlight CursorIM	guifg=NONE guibg=Green
	endif

" ==============================================================================
" 関数名の色付け設定
" [参照] http://ogawa.s18.xrea.com/tdiary/20070523.html
" ==============================================================================
	autocmd FileType ruby,c,cpp syntax match CFunction /[a-zA-Z_]\w*\s*!*\(\(\[[^]]*\]\s*\)\?(\s*[^\*]\)\@=/
	autocmd FileType ruby,c,cpp hi CFunction guifg=orange

" ==============================================================================
" 環境変数設定
" ==============================================================================
	let $dt = "~/Desktop"

" ==============================================================================
" transparency-windows-vim の設定
" [参照] http://vim-users.jp/tag/lv1/
" ==============================================================================
"	augroup hack234
"		autocmd!
"		autocmd FocusGained * set transparency=300
"		autocmd FocusLost * set transparency=200
"	augroup END

" ==============================================================================
" Grep の設定
" ==============================================================================
	" :Gc <file_type> ... <word>
	nnoremap <expr> gcr ":Gc " . expand('<cword>')
	command! -nargs=+ Gc call s:Grep_Code(<f-args>)
	function! s:Grep_Code(...)
		if a:0 < 1
			echo "error!"
		else
			execute "Grep -r ". a:000[(a:0 - 1)] . " " . g:sGrepTrgtDirPath . "/**"
		endif
	endfunction
	
	let QFix_PreviewHeight = 12
"	set shellslash	" Windowsの場合は、shellslash を設定してやると、パスの表記が簡単になります。ex) let MyGrep_ExcludeReg = '/CVS/'
	let MyGrep_ExcludeReg = '[~#]$\|\.bak$\|\.o$\|\.obj$\|\.exe$\|[/\\]tags$\|^tags$'
"	let MyGrep_Encoding = 'cp932'	"cp932を扱えないGNU grepの場合
									"Windowsでcp932を扱えないGNU grepを使用する場合、以下の様に設定します。
	let QFix_CopenCmd = 'botright'	" Quickfixウィンドウを最も下側に表示
	set winwidth=60					" アクティブウィンドウの横幅指定

" ==============================================================================
" Taglist 設定
" ==============================================================================
	let Tlist_Show_One_File = 1		" アクティブバッファのみタグ表示
	let Tlist_Use_Right_Window = 1	" 右ウィンドウ表示
	let Tlist_Exit_OnlyWindow = 1	" taglistのウインドウだけならVimを閉じる

" ==============================================================================
" MemoFile 書込設定
" Usage : :Wm 実行でデスクトップ配下に
"		  XXX.txt を作成する
" ==============================================================================
	command! Cm call CreateMemoFile()
	function! CreateMemoFile()
		let file_name_index = 1
		let MemoFilePath = 0
		while 1
			let MemoFilePath = (expand('~/Desktop/') . printf("%03d", file_name_index) . '.txt')
			if filereadable(MemoFilePath) == 1
				let file_name_index = file_name_index + 1
			else
				break
			endif
		endwhile
		execute "w " . MemoFilePath
	endfunction

" ==============================================================================
" ビジュアルモード文字数カウント
" 覚書：列番号取得には苦労した。。。
"		詳細は以下 URL 参照。
"		  http://www49.atwiki.jp/draemonash/pages/69.html
" ==============================================================================
	autocmd CursorMoved * call s:CalcSelRngStrNum()
	let s:sStrtClm = 0
	let s:sStrtRow = 0
	let s:sDiffClm = 0
	let s:sDiffRow = 0
	
	function! s:CalcSelRngStrNum()
		let l:sCurMode = mode()
		let l:sCurRow = line('.')
		if l:sCurMode == "v" || l:sCurMode == "V"
			let l:sCurClm = virtcol( [line('.'), col('.') - 1, 0] ) + 1
			let s:sDiffClm = abs( l:sCurClm - s:sStrtClm ) + 1
			let s:sDiffRow = abs( l:sCurRow - s:sStrtRow ) + 1
		elseif l:sCurMode == "\<C-v>"
			let l:sCurClm = virtcol('.')
			let s:sDiffClm = abs( l:sCurClm - s:sStrtClm ) + 1
			let s:sDiffRow = abs( l:sCurRow - s:sStrtRow ) + 1
		elseif l:sCurMode == "n"
			let l:sCurClm = virtcol( [line('.'), col('.') - 1, 0] ) + 1
			let s:sStrtClm = l:sCurClm
			let s:sStrtRow = l:sCurRow
			let s:sDiffClm = 0
			let s:sDiffRow = 0
		else
			"Do Nothing
		endif
	endfunction
	
	function! GetSelRngClmDiff()
		return s:sDiffClm
	endfunction
	
	function! GetSelRngRowDiff()
		return s:sDiffRow
	endfunction

" ==============================================================================
" 上位階層にあるタグファイルを探して、更新。
" 注意 : 事前にタグファイルを作成しておくこと。
" ==============================================================================
	function! UpdateTagFile()
		let l:sFilePath = expand("%:p")
		
		" === 上位階層ディレクトリ tags 存在確認 ====
		let l:sDirPath = s:GetTagDirPathToTop( l:sFilePath )
		
		" === tags ファイル更新 ====
		if l:sDirPath == ""
			echo "Doesn't exist tag file ... Update tag file error!"
		else
			execute "cd " . l:sDirPath
			execute "!start " . g:sCtagsPath . "/ctags.exe -R"
			execute "!start " . g:sGtagsPath . "/gtags.exe -v"
			execute "redraw"
			echo "Update tag file!"
		endif
	endfunction
	
	" === tags ファイルパス取得（＋存在確認） ====
	function! s:GetTagDirPathToTop( sFilePath )
		let l:sDirPath = ""
		let l:bIsExist = 0
		let l:asDirNames = split( a:sFilePath, "/" )
		
		" === tags 存在確認 ====
		for l:iDirMaxCnt in range( len( l:asDirNames ) - 2, 1, -1 )
			for l:iDirCnt in range( 0, l:iDirMaxCnt )
				if l:iDirCnt == 0
					let l:sDirPath = l:asDirNames[ l:iDirCnt ]
				else
					let l:sDirPath = l:sDirPath . "/" . l:asDirNames[ l:iDirCnt ]
				endif
			endfor
			if filereadable( l:sDirPath . "/tags" ) 
				let l:bIsExist = 1
				break
			else
				" Do Nothing
			endif
		endfor
		
		if l:bIsExist == 1
			return l:sDirPath
		else
			return ""
		endif
	endfunction

" ==============================================================================
" フォントサイズ設定
" フォントサイズを変更する。
" 以下のようにトグルする。
"	10 ⇒ 13 ⇒ 16 ⇒ 10 ⇒ 13 ...
" ==============================================================================
	let g:FontSizeLevel = 0
	function! ToggleFontSize()
		if g:FontSizeLevel == 0
			set guifont=MS_Gothic:h10:cSHIFTJIS
			simalt ~x
		elseif g:FontSizeLevel == 1
			set guifont=MS_Gothic:h13:cSHIFTJIS
			simalt ~x
		elseif g:FontSizeLevel == 2
			set guifont=MS_Gothic:h16:cSHIFTJIS
			simalt ~x
		else
			echo "error!"
		endif
		
		if g:FontSizeLevel < 2
			let g:FontSizeLevel = g:FontSizeLevel + 1
		else
			let g:FontSizeLevel = 0
		endif
	endfunction
	call ToggleFontSize() "初回読み込み時のフォントサイズ

" ==============================================================================
" ファイル保存時に「タブ」を「空白」に変換するかを選択する
" ==============================================================================
	let g:EnableTabConvAtSave = 0
	autocmd BufWritePre * call TabConvAtSave()
	function! TabConvAtSave()
		if g:EnableTabConvAtSave == 1
			set expandtab
			retab!
		else
			"Do Nothing
		endif
	endfunction

" ==============================================================================
" 現在開いているファイル名・ファイルパスをクリップボードにコピーする
" 参考：copypath.vim v1.0
"		http://nanasi.jp/articles/vim/copypathim.html
" ==============================================================================
	let g:Copy2UnnamedRegister = 1 " 1）無名レジスタ＋＊レジスタにコピー、それ以外)＊レジスタにコピー
	let g:ReplacePathDelimiter = 1 " 1）パス区切り「\」、0）パス区切り「/」
	
	function! CopyFilePath()
		if g:ReplacePathDelimiter == 0
			let l:sCurFilePath = expand( '%:p' )
		else
			let l:sCurFilePath = substitute( expand('%:p'), "/", "\\", "g" )
		endif
		if g:Copy2UnnamedRegister == 1
			let @* = l:sCurFilePath " * register.
			let @" = l:sCurFilePath " unnamed register.
		else
			let @* = l:sCurFilePath " * register.
		endif
		echo "copy file path      : " . l:sCurFilePath
	endfunction
	
	function! CopyFileName()
		let l:sCurFileName = expand( '%:t' )
		if g:Copy2UnnamedRegister == 1
			let @* = l:sCurFileName " * register.
			let @" = l:sCurFileName " unnamed register.
		else
			let @* = l:sCurFileName " * register.
		endif
		echo "copy file name      : " . l:sCurFileName
	endfunction
	
	function! CopyDirPath()
		let l:sCurDirPathTmp = expand("%:p")[ 0:( len( expand("%:p") ) - len( "\\" . expand("%:t") ) - 1 ) ]
		if g:ReplacePathDelimiter == 0
			let l:sCurDirPath = l:sCurDirPathTmp
		else
			let l:sCurDirPath = substitute( l:sCurDirPathTmp, "/", "\\", "g" )
		endif
		if g:Copy2UnnamedRegister == 1
			let @* = l:sCurDirPath " * register.
			let @" = l:sCurDirPath " unnamed register.
		else
			let @* = l:sCurDirPath " * register.
		endif
		echo "copy directory path : " . l:sCurDirPath
	endfunction

" ==============================================================================
" 現在のスクリプトを実行する
"   <<デフォルト時>>
"     :!%
"   <<「precmd = "python "」とした場合>>
"     :python %
"   <<「postmd = " -v"」とした場合>>
"     :% -v
" ==============================================================================
	let g:precmd = ""
	let g:postcmd = ""
	function! ExecCurrentScript()
		execute "!" . g:precmd . " % " . g:postcmd
	endfunction

" ==============================================================================
" HNXGrep で Grep する
" [参照] http://thinca.hatenablog.com/entry/20111204/1322932585
" ==============================================================================
	function! ExecuteHNXgrep()
		let l:sHNXGrepPath = substitute( g:sHNXGrepPath, "/", "\\", "g" )
		let l:sCurDirPathTmp = expand("%:p")[ 0:( len( expand("%:p") ) - len( "\\" . expand("%:t") ) - 1 ) ]
		let l:sCurDirPath = substitute( l:sCurDirPathTmp, "/", "\\", "g" )
		let l:sSearchKeyword = ""
	"	execute "!cmd.exe /c start /max " . l:sHNXGrepPath . " " . l:sCurDirPath . " /KEYWORD=" . l:sSearchKeyword
	"	execute "!cmd.exe /c start /b /max " . l:sHNXGrepPath . " " . l:sCurDirPath . " /KEYWORD=" . l:sSearchKeyword
		execute "!start " . l:sHNXGrepPath . " " . l:sCurDirPath . " /KEYWORD=" . l:sSearchKeyword
	endfunction

" ==============================================================================
" タブページを設定する
" [参考] http://thinca.hatenablog.com/entry/20111204/1322932585
" ==============================================================================
	function! MakeTabLine()
		let titles = map(range(1, tabpagenr('$')), 's:tabpage_label(v:val)')
		let sep = ' '  " タブ間の区切り
		let tabpages = join(titles, sep) . sep . '%#TabLineFill#%T'
		let info = ''  " 好きな情報を入れる
	"	let @* = tabpages . '%=' . info " * register.
	"	let @" = tabpages . '%=' . info " unnamed register.
		return tabpages . '%=' . info  " タブリストを左に、情報を右に表示
	endfunction
	" 各タブページのカレントバッファ名+αを表示
	function! s:tabpage_label(n)
		" t:title と言う変数があったらそれを使う
		let title = gettabvar(a:n, 'title')
		if title !=# ''
			return title
		endif
		
		" タブページ内のバッファのリスト
		let bufnrs = tabpagebuflist(a:n)
		
		" カレントタブページかどうかでハイライトを切り替える
		let hi = a:n is tabpagenr() ? '%#TabLineSel#' : '%#TabLine#'
		
		" バッファが複数あったらバッファ数を表示
		let no = ''
	"	let no = len(bufnrs)
	"	if no is 1
	"		let no = ''
	"	endif
		
		" タブページ内に変更ありのバッファがあったら '+' を付ける
		let mod = len(filter(copy(bufnrs), 'getbufvar(v:val, "&modified")')) ? '+' : ''
		let sp = (no . mod) ==# '' ? '' : ' '  " 隙間空ける
		
		" カレントバッファ
		let curbufnr = bufnrs[tabpagewinnr(a:n) - 1]  " tabpagewinnr() は 1 origin
		let curbufabspath = bufname(curbufnr)
		if curbufabspath == ""
			let fname = "(無題)"
		else
			if stridx( curbufabspath, '/' ) == -1
				let fname = curbufabspath
			else
				let idx = strridx( curbufabspath, '/')
				let fname = strpart( curbufabspath, idx + 1 )
			endif
		endif
		
		return '%' . a:n . 'T' . hi . ' ' . no . mod . sp . fname . ' ' . '%T%#TabLineFill#'
	endfunction

" ==============================================================================
" mark.vimの設定
" ★必ず最終行に記述すること！★
" [参照] http://nanasi.jp/articles/vim/mark_vim.html
" ==============================================================================
	execute 'source ' . g:sMarkVimPath

