" **************************************************************************************************
" *****									キーバインド設定									   *****
" **************************************************************************************************
" <<キーバインド説明>>
"	- map：キー入力を別のキーに割り当てる。
"	- noremap：キー入力を別のキーに割り当てる。
"			   ただし、再マップされないので、マップが入れ子になったり再帰的になることがない。
"		map と noremap の違いについては、以下 URL 参照
"		  http://cocopon.me/blog/?p=3871
"	- <sirent>：メッセージは表示されず、 メッセージ履歴に残らない
"	- <expr>：引数が式 (スクリプト) として扱われる。マップが実行されたときに、式が評価される。
" <<キーバインド覚書>>
"	- Ctrl+Shift+アルファベットは Vim の仕様上、キーバインドに設定できない。
"		https://github.com/vim-jp/issues/issues/756

"=== モード共通 ===
	noremap		<silent>			n			nzz											" 検索結果を画面中央に
	noremap		<silent>			N			Nzz											" 検索結果を画面中央に
	noremap		<silent>			*			*Nzz										" 検索結果を画面中央に
	noremap		<silent>			#			#nzz										" 検索結果を画面中央に
	noremap		<silent>			K			g*zz										" 検索結果を画面中央に
	noremap		<silent>			g#			g#zz										" 検索結果を画面中央に
	noremap		<silent>			x			"_x											" 削除（切り取りなし）
	noremap		<silent>			H			0											" カーソルを先頭に移動
	noremap		<silent>			L			$											" カーソルを末尾に移動
	map			<silent>			<c-m>		oa<esc>x									" インデントを維持して改行
	noremap							/			/\v
																							" very magic で検索
"	noremap							/			/\V
																							" very nomagic で検索
	noremap							ciy			ciw<c-r>0<esc>b								" 単語コピー
	noremap		<silent>			<tab>		a<tab><esc>									" タブ挿入
	noremap		<silent>			<space>		<nop>										" スペースキー無効
	noremap		<silent>			<c-j>		5jzz										" カーソル移動＋画面移動（下）
	noremap		<silent>			<c-k>		5kzz										" カーソル移動＋画面移動（上）
	noremap		<silent>			<c-h>		10zh10h										" カーソル移動＋画面移動（左）
	noremap		<silent>			<c-l>		10zl10l										" カーソル移動＋画面移動（右）
	noremap		<silent>			<c-tab>		<c-w>w										" ウィンドウ切替（次へ）
	noremap		<silent>			<c-s-tab>	<c-w>W										" ウィンドウ切替（前へ）
	noremap		<silent>			<c-s-right>	<c-w>w										" ウィンドウ切替（次へ）
	noremap		<silent>			<c-s-left>	<c-w>W										" ウィンドウ切替（前へ）
"	noremap		<silent>			<c-tab>		gt											" タブ切替（次へ）
"	noremap		<silent>			<c-s-tab>	gT											" タブ切替（前へ）
	noremap		<silent>			<c-s-down>	gt											" タブ切替（次へ）
	noremap		<silent>			<c-s-up>	gT											" タブ切替（前へ）
"	noremap		<silent>			<c-w>		:tabclose<cr>								" タブを閉じる
"	noremap		<silent>			<c-n>		:tabnew<cr>									" 新規タブを開く
	noremap		<silent>			<c-g>		:call ExecuteHNXgrep()<cr>					" HNXGrep を実行
	noremap		<silent>			<esc><esc>	:nohlsearch<cr>								" ハイライト解除
	
	noremap		<silent>			<F1>		:call BufferList()<cr>						" バッファリスト作成
	noremap		<silent>			<F2>		:Tlist<cr>									" タグリスト作成
	noremap		<silent>			<F3>		a<C-R>=strftime("%Y/%m/%d (%a)")<cr><esc>	" 現在日時出力
	noremap		<silent>			<F4>		a<C-R>=strftime("%H:%M:%S")<cr><esc>		" 現在時刻出力
	noremap		<silent>			<F5>		:execute ExecCurrentScript()<cr>			" 現在のプログラムを実行
	noremap		<silent>			<F6>		:vs<cr><c-w>wggVGy:q<cr><c-w>W				" 全体をコピー
"	noremap		<silent>			<F7>		:Vexplore<cr>								" Explorerを起動
	noremap		<silent>			<F7>		:NERDTreeToggle<CR>							" NERDtreeを起動
	noremap		<silent>			<F8>		:call ToggleFontSize()<cr>					" フォントサイズをトグル
	nmap		<silent>			<F9>		kyiwjciw<c-r>0<esc>b<c-a>j
																							" ↑前行の単語をコピーしてインクリメント
"	noremap		<silent>			<F10>		<nop>
	noremap		<silent>			<F11>		:set expandtab<cr>:retab!<cr>				" タブ⇒空白 変換
	noremap		<silent>			<F12>		:set noexpandtab<cr>:retab!<cr>				" 空白⇒タブ 変換
	
	noremap		<silent>			<c-F1>		:call CopyCurFilePath()<cr>					" 現在ファイルパスコピー
	noremap		<silent>			<c-F2>		:call CopyCurDirPath()<cr>					" 現在フォルダパスコピー
	noremap		<silent>			<c-F3>		:call CopyCurFileName()<cr>					" 現在ファイル名コピー
"	noremap		<silent>			<c-F4>		<nop>
	noremap		<silent>			<c-F5>		:call UpdateTagFile()<cr>					" タグファイル更新
	
"	noremap		<silent>	<expr>	gp			'`[' . strpart(getregtype(), 0, 1) . '`]'	" ペーストしたテキストを再選択できるようにする
	
"=== ノーマルモード ===
"	nnoremap	<silent>			<cr>		<nop>
	
"=== 挿入モード ===
	inoremap	<silent>			<c-j>		<esc>										" Ctrl+J でノーマルモードに移行
	
"=== ヴィジュアルモード ===
	vnoremap	<silent>			<			<gv											" インデント左シフト
	vnoremap	<silent>			>			>gv											" インデント右シフト
	vnoremap	<silent>			<F3>		:s/\s*$//<cr>:nohlsearch<cr>				" 末尾の空白を削除
	vnoremap	<silent>			<F4>		:s/\\/\//g<cr>								" ファイルパス区切り変換（\→/）
	vnoremap	<silent>			<F5>		:s/\v_(.)/\u\1/g<cr>						" スネークケース⇒キャメルケース変換
	vnoremap	<silent>			<F6>		:s/\v([A-Z])/_\L\1/g<cr>					" キャメルケース⇒スネークケース変換

" ==============================================================================
" Gtags用キーバインド
" [参照] http://cha.la.coocan.jp/doc/gnu_global.html#sec10
" ==============================================================================
"	map								<c-o>		:GtagsCursor<CR>
"	nnoremap						<c-d>		:Gtags <C-r><C-w><CR>
	nnoremap						<c-e>		:Gtags -r <C-r><C-w><CR>
"	nnoremap						gs			:Gtags -s <C-r><C-w><CR>
"	nnoremap						gG			:Gtags -g <C-r><C-w><CR>
"	nnoremap						,d			:<C-u>Gtags -f %<CR>
	nnoremap						<c-t>		<C-o>

" **************************************************************************************************
" *****										  基本設定										   *****
" **************************************************************************************************
" ==============================================================================
" 基本設定
" ==============================================================================
"	set guifont=MS_Gothic:h10:cSHIFTJIS					" フォントサイズ設定（フォントサイズ設定は以下の「フォントサイズ設定」参照）
"	set columns=82										" ウィンドウの横幅を～カラムにします
"	set lines=35										" ウィンドウの高さを～行にします
"	set winwidth=1										" カレントウィンドウ 最小の幅
"	set winminwidth=1									" カレントウィンドウ以外 最小の幅
"	set winheight=1										" カレントウィンドウ 最小の高さ
"	set winminheight=1									" カレントウィンドウ以外 最小の高さ
	set equalalways										" ウィンドウサイズの自動調整を有効にする
	set guioptions-=m									" メニューバーを非表示
	set guioptions+=M									" $VIMRUNTIME/menu.vim を読み込まない
	set guioptions-=T									" ツールバーを非表示
"	set guioptions+=a									" ビジュアルモードで選択している箇所をクリップボードにコピー
	set guioptions+=r									" 縦スクロールバー表示
	set guioptions+=b									" 横スクロールバー表示
	set guioptions-=e									" gVimでもテキストベースのタブページを使う
	set number											" 行番号表示
	set foldcolumn=3									" 折り畳み行のネスト表示
"	set relativenumber									" 相対行番号表示(7.3)
	set ruler											" ルーラーを表示 (noruler:非表示)
	set cmdheight=2										" コマンドラインの高さ (gvimはgvimrcで指定)
	set laststatus=2									" コマンドをステータス行に表示
"	set statusline=										" ステータスライン表示設定
"	set statusline+=\ [BufNo:\%03.3n]					" ステータスライン表示設定 buffer number
"	set statusline+=\ [Func:%{cfi#get_func_name()}]		" ステータスライン表示設定 func name（タグジャンプに異常をきたすため、使用しない）
"	set statusline+=\ %F								" ステータスライン表示設定 filepath
"	set statusline+=\ <<%t>>							" ステータスライン表示設定 filename
"	set statusline+=\ %-40(\ %m%r%h%w\ %)				" ステータスライン表示設定 status flags
"	set statusline+=\ %=								" ステータスライン表示設定 right align remainder
"	set statusline+=\ [Frmt:%{&fenc!=''?&fenc:&enc}]	" ステータスライン表示設定 file format
"	set statusline+=\ [CR/LF:%{&ff}]					" ステータスライン表示設定 line feed
"	set statusline+=\ [Asc:0x\%02.2B]					" ステータスライン表示設定 ascii code (hex)
"	set statusline+=\ [SelRng:%{GetSelRngClmDiff()}x%{GetSelRngRowDiff()}]	" ステータスライン表示設定 select width x height
"	set statusline+=\ [XPos:%03v]						" ステータスライン表示設定 cursor position
"	set showtabline=2									" タブページを常に表示
"	set tabline=%!MakeTabLine()							" タブページのラベルを設定
"	set cursorcolumn									" カーソル列を目立たせる
"	set cursorline										" カーソル行を目立たせる
	set title											" タイトルを表示
	set fileformat=dos									" 改行をWindowsの形式に変更。
	set scrolloff=5										" カーソル周辺行数
"	set swapfile										" スワップファイル(.swpファイル)を作成する
"	set directory=$VIM/__swapfiles						" スワップファイル(.swpファイル)の出力先を指定
	set noswapfile										" スワップファイル(.swpファイル)を作成しない
"	set undofile										" アンドゥファイル(.un~ファイル)を作成する
"	set undodir=$VIM/__undofiles						" アンドゥファイル(.un~ファイル)の出力先を指定
	set noundofile										" アンドゥファイル(.un~ファイル)を作成しない
"	set backup											" バックアップファイル(~ファイル)を作成する
"	set backupdir=$VIM/__backupfiles					" バックアップファイル(~ファイル)の出力先を指定
	set nobackup										" バックアップファイル(~ファイル)を作成しない
	set writebackup										" ファイルの上書きの前にバックアップを作る
														" set writebackupを指定してもオプション 'backup' がオンでない限り、
														" バックアップは上書きに成功した後に削除される。
	set viminfo+=n$VIM/_viminfo							" VIMINFO ファイル出力先設定
	set hidden											" 編集結果非保存のバッファから、新しいバッファを開くときに警告を出さない
	set history=50										" ヒストリの保存数
	set textwidth=0										" 一行が長くなった場合の自動改行を抑止する
"	set formatoptions+=mM								" 日本語の行の連結時には空白を入力しない
	set formatoptions-=tc								" 一行が長くなった場合の自動改行を抑止する
"	set formatoptions+=q								" コメントを整形する
	set virtualedit=block								" Visual blockモードでフリーカーソルを有効にする
	set backspace=indent,eol,start						" バックスペースでインデントや改行を削除できるようにする
	set ambiwidth=double								" □や○の文字があってもカーソル位置がずれないようにする
	set wildmenu										" コマンドライン補完するときに強化されたものを使う
	set timeout timeoutlen=3000 ttimeoutlen=100			" キーコードやマッピングされたキー列が完了するのを待つ時間(ミリ秒)
	set clipboard+=unnamed								" クリップボードを共有
	set nrformats-=octal								" <C-a>,<C-x> 実行にて 8 進数を無効にする。
	set nrformats-=alpha								" <C-a>,<C-x> 実行にて アルファベットを無効にする。
"	set browsedir=buffer								" ファイル保存ダイアログの初期ディレクトリをバッファファイル位置に設定
	set nocompatible									" vi互換をオフ
	set noshowcmd										" 選択中の行数、列数を表示しない（自作したので不要）（compatible 以降に記載すること）
	set shellslash										" Windowsでディレクトリパスの区切り文字表示に / を使えるようにする
	set showmatch										" 括弧の対応を数秒（0.1秒単位）表示
	set smarttab										" 行頭の余白内で tab を打ち込むと、'shiftwidth' の数だけインデントする。
	set autoindent										" 自動的にインデントする
	set smartindent										" 新しい行を作ったときに高度な自動インデントを行う
	set cinoptions+=:0									" Cインデントの設定
	set whichwrap=b,s,h,l,<,>,[,]						" カーソルを行頭、行末で止まらないようにする
	set tags+=tags;										" タグファイルのパス指定
	set nowrap											" 次のスクロールが可能。 zhで左へスクロール、zlで右へスクロール。 zHで左へ半分スクロール、zLで右へ半分スクロール
	set isfname+=32										" スペースがファイル名に入っていても、gfコマンドで開ける
	set list											" どの文字でタブや改行を表示するかを設定
	set listchars=tab:^\ ,eol:$							"	参考：set listchars=tab:>-,extends:<,trail:-,eol:<
	set nowrapscan										" 検索時にファイルの最後まで行ったら最初に戻らない
	set smartcase										" 大文字小文字の両方が含まれている場合は大文字小文字を区別
	set incsearch										" インクリメンタルサーチ
	set hlsearch										" 検索文字の強調表示
	set ignorecase										" 検索の時に大文字小文字を区別しない
	set iskeyword=a-z,A-Z,48-57,_						" w,bの移動で認識する文字
	set grepprg=internal								" vimgrep をデフォルトのgrepとする場合internal
"	set shortmess+=I									" スプラッシュ(起動時のメッセージ)を表示しない
	set noerrorbells									" エラー時の音とビジュアルベルの抑制(gvimは.gvimrcで設定)
	set visualbell t_vb=								" Beep 音を鳴らなくする
"	set lazyredraw										" マクロ実行中などの画面再描画を行わない
	set display=lastline								" Tab、行末の半角スペースを明示的に表示する
	set softtabstop=4									" ソフトタブストップ（<Tab> の挿入や <BS> の使用等の編集操作をするときに、<Tab> が対応する空白の数）
	set shiftwidth=4									" シフト移動幅（自動インデントやコマンド "<<", ">>" でずれる幅）
	set tabstop=4										" タブストップ（画面上でタブ文字が占める幅）
if has('mouse')
	set mouse=a											" マウスを有効にする
endif
	set iminsert=0										" 挿入モードでのデフォルトのIME状態設定（IM オフ）
	set imsearch=0										" 検索モードでのデフォルトのIME状態設定（IM オフ）

" ==============================================================================
" ファイルパス設定
" ==============================================================================
	let $CTAGS = expand( "$VIM/../Ctags/ctags.exe" )
	let $GTAGS = expand( "$VIM/../Gtags/bin/gtags.exe" )
	let $HNXGREP = expand( "$VIM/../HNXgrep/HNXgrep.exe" )
	let $MARKVIM = expand( "$VIM/_plugins_user/mark.vim/plugin/mark.vim" )

" ==============================================================================
" 共通ユーザ定義関数
" ==============================================================================
	function! GetCurFilePath( sPathDlmtr )
		return substitute( expand('%:p'), "/", a:sPathDlmtr, "g" )
	endfunction
	function! GetCurDirPath( sPathDlmtr )
		let l:sCurDirPathTmp = expand("%:p")[ 0:( len( expand("%:p") ) - len( "/" . expand("%:t") ) - 1 ) ]
		return substitute( l:sCurDirPathTmp, "/", a:sPathDlmtr, "g" )
	endfunction
	function! GetCurFileName()
		return expand( '%:t' )
	endfunction
	function! GetCurFileExt()
		return expand("%:e")
	endfunction
	
	" === ファイルパス検索（＋存在確認） ====
	function! SrchStoreDirPathToTop( sTrgtDirPath, sSrchFileName )
		if stridx( a:sTrgtDirPath, "\\" ) > 0
			let l:sPathDlmtr = "\\"
		elseif stridx( a:sTrgtDirPath, "/" ) > 0
			let l:sPathDlmtr = "/"
		else
			return ""
		endif
		
		" === tags 存在確認 ====
		let l:asDirNames = split( a:sTrgtDirPath, l:sPathDlmtr )
		let l:sDirPath = ""
		let l:bIsExist = 0
		for l:iDirMaxCnt in range( len( l:asDirNames ) - 1, 1, -1 )
			for l:iDirCnt in range( 0, l:iDirMaxCnt )
				if l:iDirCnt == 0
					let l:sDirPath = l:asDirNames[ l:iDirCnt ]
				else
					let l:sDirPath = l:sDirPath . l:sPathDlmtr . l:asDirNames[ l:iDirCnt ]
				endif
			endfor
			if filereadable( l:sDirPath . l:sPathDlmtr . a:sSrchFileName )
				let l:bIsExist = 1
				break
			else
				" Do Nothing
			endif
		endfor
		
		if l:bIsExist == 1
			return l:sDirPath
		else
			return ""
		endif
	endfunction

" ==============================================================================
" カラースキーマ設定
" ==============================================================================
	syntax on
	colorscheme jellybeans
	highlight NonText		guibg=NONE	guifg=#404040
	highlight SpecialKey	guibg=NONE	guifg=#707070

" ==============================================================================
" window位置の保存と復帰
" ==============================================================================
	if has('unix')
		let s:infofile = '$VIM/.vim/.vimpos'
	else
		let s:infofile = '$VIM/_vimpos'
	endif
	
	function! s:savewindowparam(filename)
		redir => pos
		exec 'winpos'
	
		redir end
		let pos = matchstr(pos, 'x[-0-9 ]\+,\s*y[-0-9 ]\+$')
		let file = expand(a:filename)
		let str = []
		let cmd = 'winpos '.substitute(pos, '[^-0-9 ]', '', 'g')
		cal add(str, cmd)
		let l = &lines
		let c = &columns
		cal add(str, 'set lines='. l.' columns='. c)
		silent! let ostr = readfile(file)
		if str != ostr
			call writefile(str, file)
		endif
	endfunction
	
	augroup savewindowparam
		autocmd!
		execute 'autocmd savewindowparam vimleave * call s:savewindowparam("'.s:infofile.'")'
	augroup end
	
	if filereadable(expand(s:infofile))
		execute 'source '.s:infofile
	endif
	unlet s:infofile

" ==============================================================================
" 挿入モード時、ステータスラインの色を変更
" ==============================================================================
	let g:hi_insert = 'highlight StatusLine guifg=darkblue guibg=darkyellow gui=none ctermfg=blue ctermbg=yellow cterm=none'
	
	if has('syntax')
		augroup InsertHook
			autocmd!
			autocmd InsertEnter * call s:StatusLine('Enter')
			autocmd InsertLeave * call s:StatusLine('Leave')
		augroup END
	endif
	
	let s:slhlcmd = ''
	function! s:StatusLine(mode)
		if a:mode == 'Enter'
			silent! let s:slhlcmd = 'highlight ' . s:GetHighlight('StatusLine')
			silent exec g:hi_insert
		else
			highlight clear StatusLine
			silent exec s:slhlcmd
		endif
	endfunction
	
	function! s:GetHighlight(hi)
		redir => hl
		exec 'highlight '.a:hi
		redir END
		let hl = substitute(hl, '[\r\n]', '', 'g')
		let hl = substitute(hl, 'xxx', '', '')
		return hl
	endfunction

" ==============================================================================
" 全角スペースを表示
"	コメント以外で全角スペースを指定しているので、scriptencodingと、
"	このファイルのエンコードが一致するよう注意！
"	強調表示されない場合、ここでscriptencodingを指定するとうまくいく事があります。
" ==============================================================================
	scriptencoding utf-8
	function! ZenkakuSpace()
		silent! let hi = s:GetHighlight('ZenkakuSpace')
		if hi =~ 'E411' || hi =~ 'cleared$'
			highlight ZenkakuSpace cterm=underline ctermfg=darkgrey gui=underline guifg=darkgrey
		endif
	endfunction
	if has('syntax')
		augroup ZenkakuSpace
			autocmd!
			autocmd ColorScheme		  * call ZenkakuSpace()
			autocmd VimEnter,WinEnter * match ZenkakuSpace /　/
		augroup END
		call ZenkakuSpace()
	endif

" ==============================================================================
" grep,tagsのためカレントディレクトリを
" ファイルと同じディレクトリに移動する
" ==============================================================================
	if exists('+autochdir')
		"autochdirがある場合カレントディレクトリを移動
		set autochdir
	else
		"autochdirが存在しないが、カレントディレクトリを移動したい場合
		au BufEnter * execute ":silent! lcd " . escape(expand("%:p:h"), ' ')
	endif

" ==============================================================================
" 外部で変更のあったファイルを自動的に読み直す(ウィンドウを移動するたび)
" [参照] http://vim-users.jp/2011/03/hack206/
" ==============================================================================
	augroup vimrc-checktime
		autocmd!
		autocmd winenter * checktime
	augroup end

" ==============================================================================
" IME カラー設定
" [参照] http://sites.google.com/site/fudist/Home/vim-nihongo-ban/vim-color
" ==============================================================================
	if has('multi_byte_ime')
		highlight Cursor	guifg=NONE guibg=Yellow
		highlight CursorIM	guifg=NONE guibg=Green
	endif

" ==============================================================================
" 関数名の色付け設定
" [参照] http://ogawa.s18.xrea.com/tdiary/20070523.html
" ==============================================================================
	autocmd FileType ruby,c,cpp syntax match CFunction /[a-zA-Z_]\w*\s*!*\(\(\[[^]]*\]\s*\)\?(\s*[^\*]\)\@=/
	autocmd FileType ruby,c,cpp hi CFunction guifg=orange

" ==============================================================================
" Grep の設定
" ==============================================================================
	" :Gc <file_type> ... <word>
	nnoremap <expr> gr ":Gc " . expand('<cword>')
	command! -nargs=+ Gc call s:Grep_Code(<f-args>)
	function! s:Grep_Code(...)
		let l:sRootDirPath = SrchStoreDirPathToTop( GetCurDirPath("\\"), "tags" )
		if l:sRootDirPath == ""
			let l:sRootDirPath = GetCurDirPath("\\")
		endif
		if a:0 < 1
			echo "error!"
		else
			execute "Grep -r ". a:000[(a:0 - 1)] . " " . l:sRootDirPath . "/**"
		endif
	endfunction

" ==============================================================================
" HNXGrep で Grep する
" [参照] http://thinca.hatenablog.com/entry/20111204/1322932585
" ==============================================================================
	let g:sProjectRootFileName = "tags"
	function! ExecuteHNXgrep()
		let l:sHNXGrepPath = substitute( $HNXGREP, "/", "\\", "g" )
		let l:sRootDirPath = SrchStoreDirPathToTop( GetCurDirPath("\\"), g:sProjectRootFileName )
		if l:sRootDirPath == ""
			let l:sRootDirPath = GetCurDirPath("\\")
		endif
		let l:sSearchKeyword = ""
	"	execute "!cmd.exe /c start /max " . l:sHNXGrepPath . " " . l:sRootDirPath . " /KEYWORD=" . l:sSearchKeyword
	"	execute "!cmd.exe /c start /b /max " . l:sHNXGrepPath . " " . l:sRootDirPath . " /KEYWORD=" . l:sSearchKeyword
		execute "!start " . l:sHNXGrepPath . " " . l:sRootDirPath . " /KEYWORD=" . l:sSearchKeyword
	endfunction

" ==============================================================================
" MemoFile 書込設定
" Usage : :Cm 実行でデスクトップ配下に
"		  temp_XXX.txt を作成する
" ==============================================================================
	command! Cm call CreateMemoFile()
	function! CreateMemoFile()
		let l:sFileNameIdx = 1
		let l:sMemoFilePath = 0
		while 1
			let l:sMemoFilePath = (expand('~/Desktop/temp_') . printf("%03d", l:sFileNameIdx) . '.txt')
			if filereadable(l:sMemoFilePath) == 1
				let l:sFileNameIdx = l:sFileNameIdx + 1
			else
				break
			endif
		endwhile
		execute "w " . l:sMemoFilePath
	endfunction

" ==============================================================================
" 上位階層にあるタグファイルを探して、更新。
" 注意 : 事前にタグファイルを作成しておくこと。
" ==============================================================================
	function! UpdateTagFile()
		" === 上位階層ディレクトリ tags 存在確認 ====
		let l:sDirPath = SrchStoreDirPathToTop( GetCurDirPath("\\"), "tags" )
		
		" === tags ファイル更新 ====
		if l:sDirPath == ""
			echo "update tag file error!! tag file is missing ..."
		else
			execute "cd " . l:sDirPath
			execute "!start " . $CTAGS . " -R"
			execute "!start " . $GTAGS . " -v"
			execute "redraw"
			echo "update tag file!!  " . l:sDirPath
		endif
	endfunction

" ==============================================================================
" フォントサイズ設定
" フォントサイズを変更する。
" 以下のようにトグルする。
"	10 ⇒ 13 ⇒ 16 ⇒ 10 ⇒ 13 ...
" ==============================================================================
	let g:FontSizeLevel = 0
	function! ToggleFontSize()
		if g:FontSizeLevel == 0
			set guifont=MS_Gothic:h10:cSHIFTJIS
			simalt ~x
		elseif g:FontSizeLevel == 1
			set guifont=MS_Gothic:h13:cSHIFTJIS
			simalt ~x
		elseif g:FontSizeLevel == 2
			set guifont=MS_Gothic:h16:cSHIFTJIS
			simalt ~x
		else
			echo "error!"
		endif
		
		if g:FontSizeLevel < 2
			let g:FontSizeLevel = g:FontSizeLevel + 1
		else
			let g:FontSizeLevel = 0
		endif
	endfunction
	call ToggleFontSize() "初回読み込み時のフォントサイズ

" ==============================================================================
" ファイル保存時に「タブ」を「空白」に変換するかを選択する
" ==============================================================================
	let g:EnableTabConvAtSave = 0
	autocmd BufWritePre * call TabConvAtSave()
	function! TabConvAtSave()
		if g:EnableTabConvAtSave == 1
			set expandtab
			retab!
		else
			"Do Nothing
		endif
	endfunction

" ==============================================================================
" 現在開いているファイル名・ファイルパスをクリップボードにコピーする
" 参考：copypath.vim v1.0
"		http://nanasi.jp/articles/vim/copypathim.html
" ==============================================================================
	let g:lCopy2UnnamedRegister = 1 " 1）無名レジスタ＋＊レジスタにコピー、それ以外)＊レジスタにコピー
	let g:sPathDlmtr = "\\"
	
	function! CopyCurFilePath()
		let l:sCurFilePath = GetCurFilePath( g:sPathDlmtr )
		if g:lCopy2UnnamedRegister == 1
			let @* = l:sCurFilePath " * register.
			let @" = l:sCurFilePath " unnamed register.
		else
			let @* = l:sCurFilePath " * register.
		endif
		echo "copy file path      : " . l:sCurFilePath
	endfunction
	
	function! CopyCurDirPath()
		let l:sCurDirPath = GetCurDirPath( g:sPathDlmtr )
		if g:lCopy2UnnamedRegister == 1
			let @* = l:sCurDirPath " * register.
			let @" = l:sCurDirPath " unnamed register.
		else
			let @* = l:sCurDirPath " * register.
		endif
		echo "copy directory path : " . l:sCurDirPath
	endfunction
	
	function! CopyCurFileName()
		let l:sCurFileName = GetCurFileName()
		if g:lCopy2UnnamedRegister == 1
			let @* = l:sCurFileName " * register.
			let @" = l:sCurFileName " unnamed register.
		else
			let @* = l:sCurFileName " * register.
		endif
		echo "copy file name      : " . l:sCurFileName
	endfunction

" ==============================================================================
" 現在のスクリプトを実行する
"	<<デフォルト時>>
"	  :!%
"	<<「cmdpre = "ruby"」とした場合>>
"	  :!ruby %
"	<<「cmdpst = "-v"」とした場合>>
"	  :!% -v
" ==============================================================================
	let g:cmdpre = ""
	let g:cmdpst = ""
	function! ExecCurrentScript()
		let l:sCurFileExt = GetCurFileExt()
		let l:sCurFileName = GetCurFileName()
		let l:sExecCmd = ""
		if stridx( l:sCurFileName, "vimrc" ) > 0
			let l:sExecCmd = "so %"
		else
			if l:sCurFileExt == "vim"
				let l:sExecCmd = "so %"
			elseif l:sCurFileExt == "py"
				let l:sExecCmd = "!python % " . g:cmdpst
			elseif l:sCurFileExt == "rb"
				let l:sExecCmd = "!ruby % " . g:cmdpst
			else
				let l:sExecCmd = "!" . g:cmdpre . " % " . g:cmdpst
			endif
		endif
		return l:sExecCmd
	endfunction

" ==============================================================================
" タブ機能無効化
" ==============================================================================
	autocmd! BufNewFile,BufRead,BufEnter,BufNew,BufWinEnter * call AutoTabPageOnly()
	let g:TabPageOnlyEnable = 1
	function! AutoTabPageOnly()
		if g:TabPageOnlyEnable == 1
			if tabpagenr() == 1
				"do nothing
			else
				execute ("tabonly")
			endif
		else
			"do nothing
		endif
	endfunction

" ==============================================================================
" タブ表示を変更する
" [参考] http://thinca.hatenablog.com/entry/20111204/1322932585
" ==============================================================================
"	function! MakeTabLine()
"		let l:asTitles = map(range(1, tabpagenr('$')), 'GetTabPageLabel(v:val)')
"		let l:sDelimiter = ' '	" タブ間の区切り
"		let l:sTabpages = join(l:asTitles, l:sDelimiter) . l:sDelimiter . '%#TabLineFill#%T'
"		let l:sInfo = ''  " 好きな情報を入れる
"		return l:sTabpages . '%=' . l:sInfo  " タブリストを左に、情報を右に表示
"	endfunction
"	" 各タブページのカレントバッファ名+αを表示
"	function! GetTabPageLabel( lTabPageNum )
"		" t:title と言う変数があったらそれを使う
"		let l:sTitle = gettabvar(a:lTabPageNum, 'l:sTitle')
"		if l:sTitle !=# ''
"			return l:sTitle
"		endif
"		
"		" タブページ内のバッファのリスト
"		let l:asBufList = tabpagebuflist(a:lTabPageNum)
"		
"		" カレントタブページかどうかでハイライトを切り替える
"		let l:sHilight = a:lTabPageNum is tabpagenr() ? '%#TabLineSel#' : '%#TabLine#'
"		
"		" バッファが複数あったらバッファ数を表示
"		let l:sBufNum = ''
"	"	let l:sBufNum = len(l:asBufList)
"	"	if l:sBufNum is 1
"	"		let l:sBufNum = ''
"	"	endif
"		
"		" タブページ内に変更ありのバッファがあったら '+' を付ける
"		let l:sModifyStat = len(filter(copy(l:asBufList), 'getbufvar(v:val, "&modified")')) ? '+' : ''
"		let l:sSpace = (l:sBufNum . l:sModifyStat) ==# '' ? '' : ' '  " 隙間空ける
"		
"		" カレントバッファ
"		let l:lCurBufIdx = l:asBufList[tabpagewinnr(a:lTabPageNum) - 1]  " tabpagewinnr() は 1 origin
"		let l:sCurBufAbsPath = bufname(l:lCurBufIdx)
"		if l:sCurBufAbsPath == ""
"			let l:sBufName = "(無題)"
"		else
"			if stridx( l:sCurBufAbsPath, '/' ) == -1
"				let l:sBufName = l:sCurBufAbsPath
"			else
"				let l:sBufName = strpart( l:sCurBufAbsPath, strridx( l:sCurBufAbsPath, '/') + 1 )
"			endif
"		endif
"		
"		return '%' . a:lTabPageNum . 'T' . l:sHilight . ' ' . l:sBufNum . l:sModifyStat . l:sSpace . l:sBufName . ' ' . '%T%#TabLineFill#'
"	endfunction

" ==============================================================================
" 現在ファイル削除コマンド
" ==============================================================================
	command! Delme call DeleteCurFile()
	function! DeleteCurFile()
		execute "!del " . GetCurFilePath( "\\" )
	endfunction

" ==============================================================================
" ウィンドウサイズ最大化
" [参考] http://d.hatena.ne.jp/akishin999/20090509/1241855699
" ==============================================================================
	au GUIEnter * simalt ~x

" ==============================================================================
" 終了時 タブ⇔空白 自動置換
" 
" ★不具合ありのため、動作しない！
" AutoRepTabSpace()は動作するが、vim 終了時に実行してくれない…
" vim 終了時に実行される autocmd を要調査
" ==============================================================================
	let g:AutoRepTabSpaceEnable = 0
	let g:AutoRepTabSpaceType = 0 "1:tab 2:space other:keep
	let g:AutoRepTabSpaceExt = 'c|h'
	
	if g:AutoRepTabSpaceEnable == 1
		autocmd BufWipeout * call AutoRepTabSpace() 
	"	execute 'autocmd! BufUnload ' . g:AutoRepTabSpaceExt ' call AutoRepTabSpace()'
	endif
	function! AutoRepTabSpace()
		"  <<本関数内で拡張子を判別する理由>>
		"	 「autocmd BufDelete *.h,*.c call AutoRepTabSpace()」でも拡張子を
		"	 指定して実行することができるが、たとえば「a.c」「a.c」「a.txt」を
		"	 読み込んだ上で「a.txt」を開き":q"を実行すると、終了時「a.txt」が
		"	 開かれているため、上記 autocmd は実行されない。
		"	 そのため、autocmdは常時実行できるよう拡張子を "*" で指定しておき、
		"	 本関数内で拡張子を判別する必要がある。
	"	redir! > redir.txt
		for l:iBufIdx in range( 1, bufnr("$") )
			if bufexists(l:iBufIdx)
				if bufname(l:iBufIdx) =~ '\.[' . g:AutoRepTabSpaceExt . ']$'
				"	echo l:iBufIdx . " " . bufname(l:iBufIdx)
					if g:AutoRepTabSpaceType == 1 "space => tab
						execute( l:iBufIdx . 'bufdo set noexpandtab' )
						execute( l:iBufIdx . 'bufdo retab!' )
						execute( l:iBufIdx . 'bufdo w' )
					elseif g:AutoRepTabSpaceType == 2 "tab => space
						execute( l:iBufIdx . 'bufdo set expandtab' )
						execute( l:iBufIdx . 'bufdo retab!' )
						execute( l:iBufIdx . 'bufdo w' )
					else
						"Do Nothing
					endif
				else
					"Do Nothing
				endif
			else
				"Do Nothing
			endif
		endfor
	"	redir END
	endfunction
	
"	"↓BufDelete の実行タイミング調査用コード
"	autocmd BufDelete * call TestFunc()
"	function! TestFunc()
"		redir! >> C:\Users\draem_000\Desktop\test2\redir.txt
"		echo "exec"
"		redir END
"	endfunction

" ==============================================================================
" 終了時 改行コード 自動置換
" ★「終了時 タブ⇔空白 自動置換」と同様の理由で動作しない！
" ==============================================================================
"	let g:AutoRepNewLineCodeEnable = 0
"	let g:AutoRepNewLineCodeType = 2 "0:Lf(unix)、1:Cr(mac)、Other:CrLf(dos)
"	let g:AutoRepNewLineCodeExt = '*.c,*.h'
"	
"	if g:AutoRepNewLineCodeEnable == 1
"		autocmd BufDelete *.c,*.h call AutoRepNewLineCode()
"	"	execute 'autocmd savewindowparam vimleave * call s:savewindowparam("'.s:infofile.'")'
"	"	execute 'autocmd! BufWinLeave ' . g:AutoRepNewLineCodeExt ' call AutoRepNewLineCode()'
"	endif
"	function! AutoRepNewLineCode()
"		if g:AutoRepNewLineCodeType == 0
"			set fileformat=unix
"		elseif g:AutoRepNewLineCodeType == 1
"			set fileformat=mac
"		else
"			set fileformat=dos
"		endif
"		execute 'w'
"	endfunction

" **************************************************************************************************
" *****										プラグイン設定									   *****
" **************************************************************************************************
" ==============================================================================
" Taglist 設定
" ==============================================================================
	let Tlist_Show_One_File = 1		" アクティブバッファのみタグ表示
	let Tlist_Use_Right_Window = 1	" 右ウィンドウ表示
	let Tlist_Exit_OnlyWindow = 1	" taglistのウインドウだけならVimを閉じる
	let Tlist_Display_Prototype = 0

" ==============================================================================
" bufferlist 設定
" ==============================================================================
	let g:BufferListWidth = 30
	let g:BufferListHideBufferList = 0
	let g:BufferListExpandBufName = 0
	let g:BufferListPreview = 0
	let g:BufferListTailWidth = 9
	let g:BufferListShortenChar = "..."
	hi BufferSelected guifg=black guibg=#9ad000 gui=bold
"	hi BufferNormal guifg=white

" ==============================================================================
" align.vim 設定
" [参照] http://vim-users.jp/2009/09/hack77/
" ==============================================================================
	let g:align_xstrlen = 3 " 日本語用

" ==============================================================================
" code_overview 設定
" [参照] http://vim-users.jp/2009/09/hack77/
" ==============================================================================
"	let g:code_overview_autostart = 1
"	let g:code_overview_use_colorscheme = 1
"	let g:codeoverview_autoupdate = 1

" =======================================
" open-browser の設定
" =======================================
	let g:netrw_nogx = 1 " disable netrw's gx mapping.
	map go <Plug>(openbrowser-smart-search)

" ==============================================================================
" mark.vim 設定
" ★カラースキーマ設定の後に記述すること！★
" [参照] http://nanasi.jp/articles/vim/mark_vim.html
" ==============================================================================
	execute 'source ' . $MARKVIM

" ==============================================================================
" qfixgrep 設定
" [参照] http://vim-users.jp/2009/09/hack77/
" ==============================================================================
	let mygrepprg = 'grep'
	let QFixWin_EnableMode = 1		" QuickFixウィンドウでもプレビューや絞り込みを有効化
	let QFix_UseLocationList = 0	" QFixHowm/QFixGrepの結果表示にロケーションリストを使用する/しない
	let QFix_PreviewHeight = 12
"	set shellslash					" Windowsの場合は、shellslash を設定してやると、パスの表記が簡単になります。ex) let MyGrep_ExcludeReg = '/CVS/'
	let MyGrep_ExcludeReg = '[~#]$\|\.bak$\|\.o$\|\.obj$\|\.exe$\|[/\\]tags$\|^tags$'
"	let MyGrep_Encoding = 'cp932'	"cp932を扱えないGNU grepの場合
									"Windowsでcp932を扱えないGNU grepを使用する場合、以下の様に設定します。
	let QFix_CopenCmd = 'botright'	" Quickfixウィンドウを最も下側に表示

